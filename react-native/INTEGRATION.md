# Integrating react-native-libsignal from Source

This guide explains how to include `react-native-libsignal` in your React
Native app directly from source (without a package registry), and how to use
the library once integrated.

---

## Prerequisites

- React Native ≥ 0.71.0 (New Architecture / JSI required)
- Android API 24+ (minSdk)
- Android NDK 27.1.12297006
- Java 17+
- The pre-built `libsignal_ffi.so` binaries must be present in the library's
  `android/jniLibs/` directory (one per ABI). These are not checked into git
  — see [Obtaining Native Binaries](#obtaining-native-binaries) below.

---

## Step 1: Copy the Library into Your Project

Copy the `react-native/` directory from this repository into your project. A
common convention is to place it under a `libs/` directory:

```
your-app/
├── android/
├── ios/
├── src/
├── libs/
│   └── react-native-libsignal/   ← copy of react-native/
│       ├── package.json
│       ├── tsconfig.json
│       ├── ts/                   ← TypeScript source
│       ├── lib/                  ← compiled JS (generated by `npx tsc`)
│       ├── cpp/                  ← C++ JSI module + generated bindings
│       ├── android/              ← Android library (build.gradle, CMake, Java, jniLibs/)
│       └── scripts/              ← build & codegen scripts
├── package.json
└── ...
```

You only need these directories from the copy:

| Directory    | Contents                                              |
|-------------|-------------------------------------------------------|
| `ts/`       | TypeScript source files                                |
| `lib/`      | Compiled JavaScript + declaration files (`npx tsc`)    |
| `cpp/`      | C++ JSI module, generated bindings, FFI headers        |
| `android/`  | Gradle library, CMakeLists, Java glue, `jniLibs/*.so`  |
| `scripts/`  | Build and codegen helper scripts                       |

The `example/`, `tests/`, and `node_modules/` directories are not needed.

---

## Step 2: Obtaining Native Binaries

The `android/jniLibs/` directory must contain pre-built `libsignal_ffi.so`
files. You have two options:

### Option A: Use the pre-built release AAR

Extract the `.so` files from the release AAR:

```bash
mkdir -p /tmp/aar-extract && cd /tmp/aar-extract
unzip /path/to/aspect-build_react-native-libsignal-release.aar
# Copy jni/ contents to jniLibs/
cp -r jni/* /path/to/your-app/libs/react-native-libsignal/android/jniLibs/
```

### Option B: Build from source

Requires the Rust toolchain with Android cross-compilation targets and
`cargo-ndk`. From the libsignal repository root:

```bash
# Install prerequisites (one-time)
rustup target add aarch64-linux-android armv7-linux-androideabi \
                  x86_64-linux-android i686-linux-android
cargo install cargo-ndk

# Build release binaries for all architectures, stripped
cd react-native
./scripts/build_android.sh --release --strip
```

This produces stripped release `.so` files in `android/jniLibs/` for all four
ABIs:

| ABI             | Target hardware                         | Typical size |
|----------------|-----------------------------------------|-------------|
| `arm64-v8a`    | Modern phones and tablets (64-bit ARM)   | ~13 MB      |
| `armeabi-v7a`  | Older 32-bit ARM devices                 | ~9 MB       |
| `x86_64`       | Emulators on Intel/AMD hosts             | ~15 MB      |
| `x86`          | Older 32-bit x86 emulators              | ~17 MB      |

---

## Step 3: Generate the C++ Header

The C++ header must be generated from the C FFI header before building:

```bash
cd libs/react-native-libsignal
cp /path/to/libsignal-repo/swift/Sources/SignalFfi/signal_ffi.h cpp/signal_ffi.h
python3 scripts/patch_header_cpp.py cpp/signal_ffi.h cpp/signal_ffi_cpp.h
```

If you used Option A above (extracting from AAR), these headers are already
present in the `cpp/` directory from the source copy.

---

## Step 4: Compile TypeScript

```bash
cd libs/react-native-libsignal
npm install          # install devDependencies (typescript)
npx tsc              # compile ts/ → lib/
```

This produces `lib/index.js`, `lib/index.d.ts`, and declaration files for all
modules.

---

## Step 5: Add the Dependency to Your App

### 5a. package.json

Add a `file:` dependency pointing to the library:

```json
{
  "dependencies": {
    "@aspect-build/react-native-libsignal": "file:./libs/react-native-libsignal"
  }
}
```

Then run `npm install` (or `yarn install`). This creates a symlink in
`node_modules/@aspect-build/react-native-libsignal` pointing to your local
copy, which React Native's autolinking will discover automatically.

### 5b. Metro bundler configuration

If your app's TypeScript source in the library references parent directories,
add the library path to Metro's `watchFolders` in `metro.config.js`:

```js
const path = require('path');

module.exports = {
  watchFolders: [
    path.resolve(__dirname, 'libs/react-native-libsignal'),
  ],
  // ... your existing config
};
```

### 5c. Verify autolinking

React Native ≥ 0.60 discovers the native module automatically via the
`react-native` config in the library's `package.json`. No manual changes to
`settings.gradle` or `MainApplication.java` are needed.

If autolinking does not work, manually register the package in your
`MainApplication.java`:

```java
import org.signal.libsignal.reactnative.LibsignalPackage;

@Override
protected List<ReactPackage> getPackages() {
    List<ReactPackage> packages = new PackageList(this).getPackages();
    packages.add(new LibsignalPackage());
    return packages;
}
```

---

## Step 6: Rebuild Your App

Since this library includes native C++ and Rust code, you must do a full
native rebuild (not just a JS bundle reload):

```bash
cd android && ./gradlew clean assembleDebug
```

---

## Verifying the Integration

Add a quick smoke test to your app's entry point:

```typescript
import { install, PrivateKey } from '@aspect-build/react-native-libsignal';

install();

const key = PrivateKey.generate();
const pub = key.getPublicKey();
console.log('libsignal working! Public key bytes:', pub.serialize().length);
// Expected output: "libsignal working! Public key bytes: 33"
```

If you see the log line, the entire native pipeline (React Native → JSI → C++
→ Rust FFI) is working correctly.

---

# API Reference

All API classes and functions are exported from the package root:

```typescript
import {
  install,
  PrivateKey,
  PublicKey,
  IdentityKeyPair,
  ProtocolAddress,
  Fingerprint,
  DisplayableFingerprint,
  ScannableFingerprint,
  Aes256GcmSiv,
  hkdf,
  AccountEntropyPool,
  KEMPublicKey,
  KEMSecretKey,
  KEMKeyPair,
  LibSignalError,
  InvalidKeyError,
  InvalidSignatureError,
  ErrorCode,
  Native,
} from '@aspect-build/react-native-libsignal';
```

## `install()`

```typescript
function install(): boolean
```

Initializes the JSI native module. **Must be called once at app startup before
any other libsignal call.** Throws an error if the native module is not linked.

```typescript
import { install } from '@aspect-build/react-native-libsignal';

// Call once in your app entry point (App.tsx, index.js, etc.)
install();
```

---

## PrivateKey

A Curve25519 private key. Used for signing, ECDH key agreement, and deriving
the corresponding public key.

| Method | Signature | Description |
|--------|-----------|-------------|
| `generate` | `static generate(): PrivateKey` | Generate a new random private key |
| `deserialize` | `static deserialize(buf: Uint8Array): PrivateKey` | Restore a private key from its serialized form |
| `serialize` | `serialize(): Uint8Array` | Serialize this key to bytes |
| `sign` | `sign(msg: Uint8Array): Uint8Array` | Sign a message (Ed25519). Returns a 64-byte signature |
| `agree` | `agree(otherKey: PublicKey): Uint8Array` | ECDH key agreement. Returns a 32-byte shared secret |
| `getPublicKey` | `getPublicKey(): PublicKey` | Derive the corresponding public key |

```typescript
const alice = PrivateKey.generate();

// Sign a message
const message = new TextEncoder().encode('hello');
const signature = alice.sign(message);

// ECDH
const bob = PrivateKey.generate();
const sharedSecret = alice.agree(bob.getPublicKey()); // 32 bytes

// Serialize / deserialize round-trip
const bytes = alice.serialize();
const restored = PrivateKey.deserialize(bytes);
```

---

## PublicKey

A Curve25519 public key (33 bytes serialized: 1 type byte + 32 key bytes).

| Method | Signature | Description |
|--------|-----------|-------------|
| `deserialize` | `static deserialize(buf: Uint8Array): PublicKey` | Deserialize from 33-byte form |
| `serialize` | `serialize(): Uint8Array` | Serialize to 33 bytes |
| `getPublicKeyBytes` | `getPublicKeyBytes(): Uint8Array` | Raw 32-byte key (no type prefix) |
| `equals` | `equals(other: PublicKey): boolean` | Compare two public keys |
| `verify` | `verify(msg: Uint8Array, sig: Uint8Array): boolean` | Verify an Ed25519 signature |
| `verifyAlternateIdentity` | `verifyAlternateIdentity(other: PublicKey, signature: Uint8Array): boolean` | Verify an alternate identity signature |

```typescript
const priv = PrivateKey.generate();
const pub = priv.getPublicKey();

// Verify a signature
const msg = new Uint8Array([1, 2, 3]);
const sig = priv.sign(msg);
console.log(pub.verify(msg, sig)); // true

// Serialize round-trip
const bytes = pub.serialize();           // 33 bytes
const restored = PublicKey.deserialize(bytes);
console.log(pub.equals(restored));       // true

// Raw key bytes (for protocols that need the 32-byte key without prefix)
const raw = pub.getPublicKeyBytes();     // 32 bytes
```

---

## IdentityKeyPair

A long-lived identity key pair consisting of a public key and private key.

| Method | Signature | Description |
|--------|-----------|-------------|
| `constructor` | `new(publicKey: PublicKey, privateKey: PrivateKey)` | Create from existing keys |
| `generate` | `static generate(): IdentityKeyPair` | Generate a new identity key pair |
| `serialize` | `serialize(): Uint8Array` | Serialize the pair to bytes |
| `signAlternateIdentity` | `signAlternateIdentity(other: PublicKey): Uint8Array` | Sign another identity key with this pair |

Properties: `publicKey: PublicKey`, `privateKey: PrivateKey`

```typescript
const identity = IdentityKeyPair.generate();
const serialized = identity.serialize();

// Sign an alternate identity
const altIdentity = IdentityKeyPair.generate();
const altSig = identity.signAlternateIdentity(altIdentity.publicKey);
const valid = identity.publicKey.verifyAlternateIdentity(
  altIdentity.publicKey,
  altSig
); // true
```

---

## ProtocolAddress

A device-specific address used to identify a Signal Protocol session endpoint.
Combines a user identifier (typically a UUID or phone number) with a device ID.

| Method | Signature | Description |
|--------|-----------|-------------|
| `new` | `static new(name: string, deviceId: number): ProtocolAddress` | Create a new address |
| `name` | `name(): string` | Get the user identifier |
| `deviceId` | `deviceId(): number` | Get the device ID |

```typescript
const addr = ProtocolAddress.new('+14155550100', 1);
console.log(addr.name());     // '+14155550100'
console.log(addr.deviceId()); // 1
```

---

## Aes256GcmSiv

AES-256-GCM-SIV authenticated encryption cipher. Provides nonce-misuse-resistant
AEAD — even if a nonce is accidentally reused, security degrades gracefully
(only revealing whether two plaintexts were identical).

| Method | Signature | Description |
|--------|-----------|-------------|
| `new` | `static new(key: Uint8Array): Aes256GcmSiv` | Create cipher with a 32-byte key |
| `encrypt` | `encrypt(plaintext: Uint8Array, nonce: Uint8Array, associatedData?: Uint8Array): Uint8Array` | Encrypt with 12-byte nonce. Returns ciphertext + 16-byte auth tag |
| `decrypt` | `decrypt(ciphertext: Uint8Array, nonce: Uint8Array, associatedData?: Uint8Array): Uint8Array` | Decrypt and verify. Throws on authentication failure |

```typescript
import { Aes256GcmSiv } from '@aspect-build/react-native-libsignal';

const key = crypto.getRandomValues(new Uint8Array(32));
const nonce = crypto.getRandomValues(new Uint8Array(12));
const cipher = Aes256GcmSiv.new(key);

const plaintext = new TextEncoder().encode('secret message');
const encrypted = cipher.encrypt(plaintext, nonce);
const decrypted = cipher.decrypt(encrypted, nonce);
// decrypted equals plaintext

// With associated data (authenticated but not encrypted)
const aad = new TextEncoder().encode('metadata');
const enc2 = cipher.encrypt(plaintext, nonce, aad);
const dec2 = cipher.decrypt(enc2, nonce, aad);
```

---

## hkdf

HKDF key derivation (RFC 5869). Derives cryptographic key material from input
key material using an extract-then-expand approach.

```typescript
function hkdf(
  outputLength: number,
  inputKeyMaterial: Uint8Array,
  info: Uint8Array,
  salt?: Uint8Array
): Uint8Array
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `outputLength` | `number` | Number of bytes to derive (max 255 × 32 = 8160) |
| `inputKeyMaterial` | `Uint8Array` | Source key material |
| `info` | `Uint8Array` | Context / application-specific info string |
| `salt` | `Uint8Array` | Optional salt (defaults to empty) |

**Returns:** `Uint8Array` of `outputLength` bytes.

```typescript
import { hkdf } from '@aspect-build/react-native-libsignal';

const ikm = crypto.getRandomValues(new Uint8Array(32));
const info = new TextEncoder().encode('MyApp-v1');
const salt = crypto.getRandomValues(new Uint8Array(32));

const derivedKey = hkdf(32, ikm, info, salt); // 32-byte derived key
```

---

## Fingerprint

Identity verification fingerprints. Used to verify that two parties have the
same view of each other's identity keys, either by comparing numeric strings
visually or scanning QR codes.

### Fingerprint

| Method | Signature | Description |
|--------|-----------|-------------|
| `new` | `static new(iterations, version, localIdentifier, localKey, remoteIdentifier, remoteKey)` | Create a fingerprint from identity keys |
| `displayableFingerprint` | `displayableFingerprint(): DisplayableFingerprint` | Get the human-readable numeric form |
| `scannableFingerprint` | `scannableFingerprint(): ScannableFingerprint` | Get the binary form for QR codes |

Full signature of `Fingerprint.new`:

```typescript
static new(
  iterations: number,         // Hash iterations (e.g., 5200)
  version: number,            // Protocol version (e.g., 1)
  localIdentifier: Uint8Array,  // Local user's stable identifier
  localKey: PublicKey,         // Local identity public key
  remoteIdentifier: Uint8Array, // Remote user's stable identifier
  remoteKey: PublicKey          // Remote identity public key
): Fingerprint
```

### DisplayableFingerprint

| Method | Signature | Description |
|--------|-----------|-------------|
| `toString` | `toString(): string` | 60-digit numeric string (12 groups of 5 digits) |

### ScannableFingerprint

| Method | Signature | Description |
|--------|-----------|-------------|
| `toBuffer` | `toBuffer(): Uint8Array` | Serialize to bytes (for QR code encoding) |
| `compare` | `compare(other: Uint8Array): boolean` | Compare with another scannable fingerprint's bytes |

```typescript
import { Fingerprint, PrivateKey } from '@aspect-build/react-native-libsignal';

const alice = PrivateKey.generate().getPublicKey();
const bob = PrivateKey.generate().getPublicKey();

const aliceId = new TextEncoder().encode('alice-uuid');
const bobId = new TextEncoder().encode('bob-uuid');

const fingerprint = Fingerprint.new(5200, 1, aliceId, alice, bobId, bob);

// Display to user for visual comparison
const displayable = fingerprint.displayableFingerprint().toString();
// e.g., "38421 09516 98797 ..." (60 digits)

// Encode for QR code
const scannable = fingerprint.scannableFingerprint();
const qrData = scannable.toBuffer();

// Compare scanned QR with expected
const matches = scannable.compare(otherScannableBytes);
```

---

## AccountEntropyPool

A random entropy pool used for deriving backup keys and other account-level
secrets.

| Method | Signature | Description |
|--------|-----------|-------------|
| `generate` | `static generate(): AccountEntropyPool` | Generate a new random pool |
| `deriveBackupKey` | `deriveBackupKey(): Uint8Array` | Derive a backup key |
| `toString` | `toString(): string` | Get the raw entropy string (64 hex chars) |

```typescript
import { AccountEntropyPool } from '@aspect-build/react-native-libsignal';

const pool = AccountEntropyPool.generate();
console.log(pool.toString()); // 64-character hex string

const backupKey = pool.deriveBackupKey();
```

---

## KEMKeyPair / KEMPublicKey / KEMSecretKey

Post-quantum key encapsulation (Kyber-1024). Used for quantum-resistant key
exchange in the Signal Protocol's PQXDH key agreement.

### KEMKeyPair

| Method | Signature | Description |
|--------|-----------|-------------|
| `generate` | `static generate(): KEMKeyPair` | Generate a new Kyber-1024 key pair |

Properties: `publicKey: KEMPublicKey`, `secretKey: KEMSecretKey`

### KEMPublicKey / KEMSecretKey

| Method | Signature | Description |
|--------|-----------|-------------|
| `deserialize` | `static deserialize(buf: Uint8Array): KEMPublicKey` | Deserialize from bytes |
| `serialize` | `serialize(): Uint8Array` | Serialize to bytes |

```typescript
import { KEMKeyPair } from '@aspect-build/react-native-libsignal';

const pair = KEMKeyPair.generate();
const pubBytes = pair.publicKey.serialize();
const secBytes = pair.secretKey.serialize();

// Round-trip
const restored = KEMPublicKey.deserialize(pubBytes);
```

---

## Error Types

All libsignal errors extend `LibSignalError`, which extends the standard
`Error` class with a `code` field.

### ErrorCode

```typescript
enum ErrorCode {
  Generic          = 0,
  InvalidArgument  = 1,
  InvalidState     = 2,
  InternalError    = 3,
  InvalidKey       = 4,
  InvalidSignature = 5,
  ProtocolError    = 6,
  CryptoError      = 7,
}
```

### Error Classes

| Class | ErrorCode | When thrown |
|-------|-----------|------------|
| `LibSignalError` | varies | Base class for all libsignal errors |
| `InvalidKeyError` | `InvalidKey` | Invalid key data (wrong length, bad format) |
| `InvalidSignatureError` | `InvalidSignature` | Signature verification failure |

```typescript
import {
  PublicKey,
  LibSignalError,
  ErrorCode,
} from '@aspect-build/react-native-libsignal';

try {
  PublicKey.deserialize(new Uint8Array([0x00])); // too short
} catch (e) {
  if (e instanceof LibSignalError) {
    console.log(e.code);    // ErrorCode value
    console.log(e.message); // human-readable description
  }
}
```

---

## Low-Level Native API

For operations not covered by the high-level classes (e.g., sealed sender
encryption, group cipher operations, session management), the full set of 438
JSI-bound FFI functions is available via the `__libsignal_native` global
object, which is installed by `install()`.

```typescript
import { install, Native } from '@aspect-build/react-native-libsignal';

install();

// The global is a JSI HostObject with all FFI functions
const n = (globalThis as any).__libsignal_native;

// Example: sealed sender encryption, group operations, etc.
const result = n.SomeFunction_Name(arg1, arg2);
```

The complete list of function signatures is defined in `ts/Native.ts`. Each
function name corresponds directly to the C FFI function in `signal_ffi.h`
with the `signal_` prefix removed and converted to PascalCase. For example:

| C FFI function | JSI function name |
|---------------|-------------------|
| `signal_publickey_serialize` | `PublicKey_Serialize` |
| `signal_privatekey_generate` | `PrivateKey_Generate` |
| `signal_aes256_gcm_siv_new` | `Aes256GcmSiv_New` |
| `signal_sealed_sender_encrypt` | `SealedSender_Encrypt` |

### Native pointer handles

Many native functions return opaque pointer handles (wrapped as JSI
HostObjects). These handles are automatically garbage-collected — when the JS
object is finalized, the corresponding Rust resource is freed via the
appropriate `signal_*_destroy` function.

High-level API classes expose their handle via the `_nativeHandle` property,
allowing you to mix high-level and low-level calls:

```typescript
const key = PrivateKey.generate();
const n = (globalThis as any).__libsignal_native;

// Use the high-level object's handle with a low-level function
const serialized = n.PrivateKey_Serialize(key._nativeHandle);
```

---

## Supported Architectures

The release build includes native code for all common Android architectures:

| ABI | Architecture | Typical use |
|-----|-------------|-------------|
| `arm64-v8a` | ARMv8-A 64-bit | All modern Android phones and tablets |
| `armeabi-v7a` | ARMv7-A 32-bit | Older phones, some IoT devices |
| `x86_64` | x86 64-bit | Android emulators on Intel/AMD development machines |
| `x86` | x86 32-bit | Older Android emulators |

The app's ABI filters determine which architectures are included in the final
APK. To include all four, set in your app's `android/app/build.gradle`:

```groovy
android {
    defaultConfig {
        ndk {
            abiFilters "arm64-v8a", "armeabi-v7a", "x86_64", "x86"
        }
    }
}
```

For smaller APK size, use Android App Bundles (AAB) which deliver only the
relevant ABI to each device, or filter to just the architectures you need:

```groovy
// Production-only (covers >99% of active devices)
abiFilters "arm64-v8a"

// Production + emulator development
abiFilters "arm64-v8a", "x86_64"
```

---

## Limitations

- **Android only** — iOS support requires a macOS build environment and is not
  yet implemented.
- **No session store callbacks** — `SessionStore`, `PreKeyStore`,
  `IdentityKeyStore`, and `SenderKeyStore` require bidirectional JS↔Rust
  callback plumbing and are not implemented. Applications needing full session
  management should implement their own storage layer and use the low-level
  native functions.
- **Network functions require a Signal server** — Chat connections, CDSI
  lookup, registration, and attestation functions require Signal server
  credentials and connectivity.
