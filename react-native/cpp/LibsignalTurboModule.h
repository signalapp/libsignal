//
// Copyright 2024 Signal Messenger, LLC.
// SPDX-License-Identifier: AGPL-3.0-only
//

#pragma once

#include <jsi/jsi.h>
#include <ReactCommon/CallInvoker.h>
#include <memory>
#include <string>
#include <unordered_map>
#include <vector>
#include <functional>
#include <cstring>
#include <mutex>

// signal_ffi_cpp.h is a C++-compatible version of signal_ffi.h.
// Generated by patching the cbindgen output to use `enum X : uint8_t {}`
// instead of the C-style `enum X {}; typedef uint8_t X;` pattern.
// See scripts/build_android.sh for the sed transformation.
extern "C" {
#include "signal_ffi_cpp.h"
}

namespace libsignal {

using namespace facebook;

// Forward declaration
class NativePointer;

// Callback for resolving async promises from background threads.
// The resolve/reject callbacks dispatch to the JS thread via CallInvoker,
// so they are safe to call from any thread.
struct PromiseResolver {
    // Resolve with a simple boolean value
    std::function<void(bool)> resolve_bool;
    // Resolve with a simple integer value
    std::function<void(int32_t)> resolve_int;
    // Resolve with null
    std::function<void()> resolve_null;
    // Reject with an error message
    std::function<void(std::string)> reject;
    // Resolve with a buffer (Uint8Array) â€” data is copied on the JS thread
    std::function<void(std::shared_ptr<std::vector<uint8_t>>)> resolve_with_data;
    // Resolve with a NativePointer HostObject wrapping a raw pointer
    std::function<void(void*)> resolve_with_pointer;
};

/**
 * A HostObject wrapper around a native pointer that calls the appropriate
 * signal_*_destroy function when garbage-collected.
 */
class NativePointer : public jsi::HostObject {
public:
    using Destructor = void (*)(void*);

    NativePointer(void* ptr, Destructor destructor)
        : ptr_(ptr), destructor_(destructor) {}

    ~NativePointer() override {
        if (ptr_ && destructor_) {
            destructor_(ptr_);
        }
    }

    void* get() const { return ptr_; }

    // Prevent copying
    NativePointer(const NativePointer&) = delete;
    NativePointer& operator=(const NativePointer&) = delete;

    jsi::Value get(jsi::Runtime& rt, const jsi::PropNameID& name) override {
        auto propName = name.utf8(rt);
        if (propName == "_pointer") {
            return jsi::BigInt::fromUint64(rt, reinterpret_cast<uint64_t>(ptr_));
        }
        return jsi::Value::undefined();
    }

    std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& rt) override {
        std::vector<jsi::PropNameID> names;
        names.push_back(jsi::PropNameID::forAscii(rt, "_pointer"));
        return names;
    }

private:
    void* ptr_;
    Destructor destructor_;
};

/**
 * The main JSI HostObject that exposes all signal_* functions to JavaScript.
 *
 * Usage from JS:
 *   const native = global.__libsignal_native;
 *   const key = native.PrivateKey_Generate();
 *   const serialized = native.PrivateKey_Serialize(key);
 */
class LibsignalModule : public jsi::HostObject {
public:
    explicit LibsignalModule(jsi::Runtime& runtime, std::shared_ptr<facebook::react::CallInvoker> callInvoker);
    ~LibsignalModule();

    jsi::Value get(jsi::Runtime& rt, const jsi::PropNameID& name) override;
    std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& rt) override;

    /**
     * Install the module as global.__libsignal_native on the given runtime.
     */
    static void install(jsi::Runtime& runtime, std::shared_ptr<facebook::react::CallInvoker> callInvoker = nullptr);

    /**
     * Get the shared CallInvoker for dispatching to the JS thread.
     */
    std::shared_ptr<facebook::react::CallInvoker> getCallInvoker() const { return callInvoker_; }

    /**
     * Get the TokioAsyncContext for async FFI calls.
     */
    SignalConstPointerTokioAsyncContext getAsyncContext() const { return asyncContext_; }

private:
    // Function registry: maps JS function name -> C++ implementation
    using JsiFunction = std::function<jsi::Value(
        jsi::Runtime& rt,
        const jsi::Value& thisVal,
        const jsi::Value* args,
        size_t count)>;

    std::unordered_map<std::string, JsiFunction> functions_;
    std::shared_ptr<facebook::react::CallInvoker> callInvoker_;
    SignalConstPointerTokioAsyncContext asyncContext_;
    bool ownsAsyncContext_;

    // Hand-written function registrations (stores, listeners, logger, etc.)
    void registerHandwrittenFunctions(jsi::Runtime& rt);

    // Auto-generated function registrations (from gen_jsi_bindings.py)
    void registerGeneratedFunctions(jsi::Runtime& rt);

    // Auto-generated property names list
    std::vector<jsi::PropNameID> getGeneratedPropertyNames(jsi::Runtime& rt);

    // ---------------------------------------------------------------
    // Type conversion helpers
    // ---------------------------------------------------------------

    /**
     * Convert a JSI value (Uint8Array / ArrayBuffer) to a SignalBorrowedBuffer.
     * The returned buffer borrows from the JSI value and must not outlive it.
     */
    static SignalBorrowedBuffer jsiToBuffer(jsi::Runtime& rt, const jsi::Value& val);

    /**
     * Convert a JSI value to a SignalBorrowedMutableBuffer.
     */
    static SignalBorrowedMutableBuffer jsiToMutableBuffer(jsi::Runtime& rt, const jsi::Value& val);

    /**
     * Convert a JSI string value to a std::string.
     */
    static std::string jsiToString(jsi::Runtime& rt, const jsi::Value& val);

    /**
     * Convert a JSI value to a SignalUuid.
     */
    static SignalUuid jsiToUuid(jsi::Runtime& rt, const jsi::Value& val);

    /**
     * Convert a JSI value to a ServiceIdFixedWidthBinaryBytes (writes into out).
     */
    static void jsiToServiceId(jsi::Runtime& rt, const jsi::Value& val, SignalServiceIdFixedWidthBinaryBytes out);

    /**
     * Convert a JSI value to a fixed-size byte buffer (returned as vector).
     */
    static std::vector<uint8_t> jsiToFixedBuffer(jsi::Runtime& rt, const jsi::Value& val);

    /**
     * Convert a JSI array to a SignalBorrowedBytestringArray.
     */
    static SignalBorrowedBytestringArray jsiToBytestringArray(jsi::Runtime& rt, const jsi::Value& val);

    /**
     * RAII wrapper for a borrowed slice of buffers (owns the temporary arrays).
     */
    struct BorrowedSliceOfBuffers {
        SignalBorrowedSliceOfBuffers slice;
        std::vector<SignalBorrowedBuffer> buffers;
    };

    /**
     * Convert a JSI array of Uint8Array to a SignalBorrowedSliceOfBuffers.
     * The returned struct owns the temporary buffer array and must outlive the C call.
     */
    static BorrowedSliceOfBuffers jsiToSliceOfBuffers(jsi::Runtime& rt, const jsi::Value& val);

    /**
     * RAII wrapper for a borrowed slice of const pointers (owns the temporary array).
     */
    template<typename SliceType>
    struct BorrowedSliceOfPointers {
        SliceType slice;
        std::vector<typename std::remove_const<
            typename std::remove_pointer<decltype(SliceType::base)>::type>::type> pointers;
    };

    /**
     * Convert a JSI array of NativePointer HostObjects to a borrowed slice of const pointers.
     */
    template<typename SliceType>
    static BorrowedSliceOfPointers<SliceType> jsiToSliceOfPointers(jsi::Runtime& rt, const jsi::Value& val) {
        using ElemType = typename std::remove_const<
            typename std::remove_pointer<decltype(SliceType::base)>::type>::type;

        BorrowedSliceOfPointers<SliceType> result;

        auto obj = val.asObject(rt);
        auto arr = obj.asArray(rt);
        size_t len = arr.size(rt);

        result.pointers.resize(len);
        for (size_t i = 0; i < len; i++) {
            auto elem = arr.getValueAtIndex(rt, i);
            auto hostObj = elem.asObject(rt).asHostObject<NativePointer>(rt);
            result.pointers[i].raw = reinterpret_cast<
                typename std::remove_pointer<decltype(ElemType::raw)>::type*>(
                    hostObj->get());
        }

        result.slice.base = result.pointers.data();
        result.slice.length = len;
        return result;
    }

    /**
     * Extract a NativePointer from a JSI HostObject value.
     */
    template<typename T>
    static T jsiToConstPointer(jsi::Runtime& rt, const jsi::Value& val) {
        if (val.isNull() || val.isUndefined()) {
            return T{nullptr};
        }
        auto obj = val.asObject(rt);
        auto hostObj = obj.asHostObject<NativePointer>(rt);
        T wrapper;
        wrapper.raw = reinterpret_cast<
            typename std::remove_pointer<decltype(wrapper.raw)>::type*>(
                hostObj->get());
        return wrapper;
    }

    template<typename T>
    static T jsiToMutPointer(jsi::Runtime& rt, const jsi::Value& val) {
        if (val.isNull() || val.isUndefined()) {
            return T{nullptr};
        }
        auto obj = val.asObject(rt);
        auto hostObj = obj.asHostObject<NativePointer>(rt);
        T wrapper;
        wrapper.raw = reinterpret_cast<
            typename std::remove_pointer<decltype(wrapper.raw)>::type*>(
                hostObj->get());
        return wrapper;
    }

    // ---------------------------------------------------------------
    // Output conversion helpers
    // ---------------------------------------------------------------

    /**
     * Wrap a native pointer in a NativePointer HostObject for GC-driven cleanup.
     */
    template<typename WrapperType>
    static jsi::Value pointerToJsi(jsi::Runtime& rt, WrapperType ptr) {
        if (!ptr.raw) {
            return jsi::Value::null();
        }
        auto pointerObj = std::make_shared<NativePointer>(
            reinterpret_cast<void*>(ptr.raw),
            nullptr  // destructor set per-type at call site
        );
        return jsi::Object::createFromHostObject(rt, pointerObj);
    }

    /**
     * Convert a SignalOwnedBuffer to a Uint8Array, freeing the buffer.
     */
    static jsi::Value ownedBufferToJsi(jsi::Runtime& rt, SignalOwnedBuffer buf);

    /**
     * Convert a fixed-size array to a Uint8Array.
     */
    static jsi::Value fixedArrayToJsi(jsi::Runtime& rt, const uint8_t* data, size_t len);

    /**
     * Convert a C string to a JSI string value, freeing the C string.
     */
    static jsi::Value stringToJsi(jsi::Runtime& rt, const char* str);

    /**
     * Convert a SignalUuid to a JSI Uint8Array.
     */
    static jsi::Value uuidToJsi(jsi::Runtime& rt, const SignalUuid& uuid);

    /**
     * Convert a SignalBytestringArray to a JSI array, freeing the native array.
     */
    static jsi::Value bytestringArrayToJsi(jsi::Runtime& rt, SignalBytestringArray& arr);

    // ---------------------------------------------------------------
    // Error handling
    // ---------------------------------------------------------------

    /**
     * Check a SignalFfiError* and throw a JSI exception if non-null.
     * The error is freed after extracting the message.
     */
    static void checkError(jsi::Runtime& rt, SignalFfiError* err);

    // ---------------------------------------------------------------
    // Async helpers
    // ---------------------------------------------------------------

    /**
     * Create a JS Promise that runs an FFI call on a background thread.
     * The module pointer provides access to the CallInvoker for thread-safe
     * dispatch and the TokioAsyncContext for async FFI calls.
     */
    static jsi::Value createAsyncCall(
        jsi::Runtime& rt,
        const jsi::Value* args,
        size_t count,
        std::shared_ptr<facebook::react::CallInvoker> callInvoker,
        std::function<void(jsi::Runtime&, const jsi::Value*, size_t, PromiseResolver)> work);
};

} // namespace libsignal
