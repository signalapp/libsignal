//
// Copyright 2024 Signal Messenger, LLC.
// SPDX-License-Identifier: AGPL-3.0-only
//

use std::fmt::Write as _;

fn main() {
    const SERVICE_PROTOS: &[&str] = &[
        "proto/google/rpc/error_details.proto",
        "proto/google/rpc/status.proto",
        "proto/org/signal/chat/account.proto",
        "proto/org/signal/chat/backups.proto",
        "proto/org/signal/chat/calling.proto",
        "proto/org/signal/chat/call_quality.proto",
        "proto/org/signal/chat/credentials.proto",
        "proto/org/signal/chat/device.proto",
        "proto/org/signal/chat/keys.proto",
        "proto/org/signal/chat/payments.proto",
        "proto/org/signal/chat/profile.proto",
    ];
    println!("cargo:rerun-if-changed=proto/");

    let mut config = tonic_prost_build::Config::new();
    let fds = config
        .load_fds(SERVICE_PROTOS, &["proto/"])
        .expect("can parse protos");

    let service_method_contents = collect_services_as_enums(&fds);

    let mut service_method_file =
        std::path::PathBuf::from(std::env::var_os("OUT_DIR").expect("OUT_DIR should be set"));
    service_method_file.push("service_methods.rs");
    std::fs::write(service_method_file, service_method_contents).expect("can write to OUT_DIR");

    tonic_prost_build::configure()
        .build_server(false)
        .build_transport(false)
        .compile_fds_with_config(fds, config)
        .expect("can generate code");
}

fn collect_services_as_enums(fds: &tonic_prost_build::FileDescriptorSet) -> String {
    let mut service_method_contents = "// This file is @generated by build.rs.\n".to_owned();

    for file in &fds.file {
        for service in &file.service {
            writeln!(
                service_method_contents,
                concat!(
                    "#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, ::strum::EnumIter, ::strum::IntoStaticStr)]\n",
                    "#[strum(prefix = \"{0}\")]\n",
                    "pub enum {0} {{"
                ),
                service.name()
            )
            .expect("can write to String");

            for method in &service.method {
                writeln!(service_method_contents, "    {},", method.name())
                    .expect("can write to String");
            }

            writeln!(service_method_contents, "}}\n").expect("can write to String");
        }
    }
    service_method_contents
}
