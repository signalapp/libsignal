//
// Copyright 2020 Signal Messenger, LLC.
// SPDX-License-Identifier: AGPL-3.0-only
//

// WARNING: this file was automatically generated

export type Uuid = Uint8Array;

/// A Native.Timestamp may be measured in seconds or in milliseconds;
/// what's important is that it's an integer less than Number.MAX_SAFE_INTEGER.
export type Timestamp = number;

// Rust code produces or consumes values that conform to these interface
// definitions. They must be kept in sync to prevent bridging errors.

export type LookupResponse = {
  entries: Map<string, LookupResponseEntry>;
  debugPermitsUsed: number;
};

export type LookupResponseEntry = {
  readonly aci: string | undefined;
  readonly pni: string | undefined;
};

export type ChatResponse = {
  status: number;
  message: string | undefined;
  headers: ReadonlyArray<[string, string]>;
  body: Uint8Array | undefined;
};

export type ChatServiceDebugInfo = {
  ipType: number;
  durationMillis: number;
  connectionInfo: string;
};

export type ResponseAndDebugInfo = {
  response: ChatResponse;
  debugInfo: ChatServiceDebugInfo;
};

export type SealedSenderMultiRecipientMessageRecipient = {
  deviceIds: number[];
  registrationIds: number[];
  rangeOffset: number;
  rangeLen: number;
};

export type SealedSenderMultiRecipientMessage = {
  recipientMap: {
    [serviceId: string]: SealedSenderMultiRecipientMessageRecipient;
  };
  excludedRecipients: string[];
  offsetOfSharedData: number;
};

export enum IdentityChange {
  // This must be kept in sync with the Rust enum of the same name.
  NewOrUnchanged = 0,
  ReplacedExisting = 1,
}

export type IdentityKeyStore = {
  _getIdentityKey: () => Promise<PrivateKey>;
  _getLocalRegistrationId: () => Promise<number>;
  _saveIdentity: (
    name: ProtocolAddress,
    key: PublicKey
  ) => Promise<IdentityChange>;
  _isTrustedIdentity: (
    name: ProtocolAddress,
    key: PublicKey,
    sending: boolean
  ) => Promise<boolean>;
  _getIdentity: (name: ProtocolAddress) => Promise<PublicKey | null>;
};

export type SessionStore = {
  _saveSession: (addr: ProtocolAddress, record: SessionRecord) => Promise<void>;
  _getSession: (addr: ProtocolAddress) => Promise<SessionRecord | null>;
};

export type PreKeyStore = {
  _savePreKey: (preKeyId: number, record: PreKeyRecord) => Promise<void>;
  _getPreKey: (preKeyId: number) => Promise<PreKeyRecord>;
  _removePreKey: (preKeyId: number) => Promise<void>;
};

export type SignedPreKeyStore = {
  _saveSignedPreKey: (
    signedPreKeyId: number,
    record: SignedPreKeyRecord
  ) => Promise<void>;
  _getSignedPreKey: (signedPreKeyId: number) => Promise<SignedPreKeyRecord>;
};

export type KyberPreKeyStore = {
  _saveKyberPreKey: (
    kyberPreKeyId: number,
    record: KyberPreKeyRecord
  ) => Promise<void>;
  _getKyberPreKey: (kyberPreKeyId: number) => Promise<KyberPreKeyRecord>;
  _markKyberPreKeyUsed: (
    kyberPreKeyId: number,
    signedPreKeyId: number,
    baseKey: PublicKey
  ) => Promise<void>;
};

export type SenderKeyStore = {
  _saveSenderKey: (
    sender: ProtocolAddress,
    distributionId: Uuid,
    record: SenderKeyRecord
  ) => Promise<void>;
  _getSenderKey: (
    sender: ProtocolAddress,
    distributionId: Uuid
  ) => Promise<SenderKeyRecord | null>;
};

export type InputStream = {
  _read: (amount: number) => Promise<Uint8Array>;
  _skip: (amount: number) => Promise<void>;
};

export type SyncInputStream = Uint8Array;

export type ChatListener = {
  _incoming_message: (
    envelope: Uint8Array,
    timestamp: number,
    ack: ServerMessageAck
  ) => void;
  _queue_empty: () => void;
  _received_alerts: (alerts: string[]) => void;
  _connection_interrupted: (
    // A LibSignalError or null, but not naming the type to avoid circular import dependencies.
    reason: Error | null
  ) => void;
};

export type ChallengeOption = 'pushChallenge' | 'captcha';

export type RegistrationPushTokenType = 'apn' | 'fcm';

export type RegistrationCreateSessionRequest = {
  number: string;
  push_token?: string;
  push_token_type?: RegistrationPushTokenType;
  mcc?: string;
  mnc?: string;
};

export type RegisterResponseBadge = {
  id: string;
  visible: boolean;
  expirationSeconds: number;
};

export type CheckSvr2CredentialsResponse = Map<
  string,
  'match' | 'no-match' | 'invalid'
>;

export type SignedPublicPreKey = {
  keyId: number;
  publicKey: Uint8Array;
  signature: Uint8Array;
};

export type Wrapper<T> = Readonly<{
  _nativeHandle: T;
}>;

export type MessageBackupValidationOutcome = {
  errorMessage: string | null;
  unknownFieldMessages: Array<string>;
};

export type BackupJsonFrameError = {
  message: string;
  unknownFields: string[];
};

export type BackupJsonFrameResult = {
  line?: string;
  error?: BackupJsonFrameError;
};

export type JsonFrameExportResult = BackupJsonFrameResult;

export type AccountEntropyPool = string;

export type CancellablePromise<T> = Promise<T> & {
  _cancellationToken: bigint;
};

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export type Serialized<T> = Uint8Array;

type ConnectChatBridge = Wrapper<ConnectionManager>;
type TestingFutureCancellationGuard = Wrapper<TestingFutureCancellationCounter>;

import load from 'node-gyp-build';

type NativeFunctions = {
  registerErrors: (errorsModule: Record<string, unknown>) => void;
  NATIVE_FNS;
};

const { registerErrors, NATIVE_FN_NAMES } = load(
  `${import.meta.dirname}/../`
) as NativeFunctions;

export { registerErrors, NATIVE_FN_NAMES };

/* eslint-disable comma-dangle */
NATIVE_TYPES;
